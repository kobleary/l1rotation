<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Getting Started • l1rotation</title>
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><script src="../deps/MathJax-3.2.2/tex-chtml.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Getting Started">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">l1rotation</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/documentation.html">Getting Started</a></li>
    <li><a class="dropdown-item" href="../articles/intuition.html">Background and Intuition</a></li>
    <li><a class="dropdown-item" href="../articles/macro_application.html">Application</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/SimonFreyaldenhoven/l1rotation/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Getting Started</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/SimonFreyaldenhoven/l1rotation/blob/HEAD/vignettes/documentation.Rmd" class="external-link"><code>vignettes/documentation.Rmd</code></a></small>
      <div class="d-none name"><code>documentation.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="intro">Introduction<a class="anchor" aria-label="anchor" href="#intro"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://kobleary.github.io/l1rotation/">l1rotation</a></span><span class="op">)</span></span></code></pre></div>
<p>The <code>l1rotation</code> package offers functionality to simplify
the loading matrix in factor models. It can find the most sparse
rotation of the loading matrix using the l1-rotation criterion of <a href="https://simonfreyaldenhoven.github.io/papers/factor_rotation.pdf" class="external-link">Freyaldenhoven
(2025)</a>.</p>
<p>Under the assumption of sparsity in the true loading matrix, it also
solves the problem of rotational indeterminacy inherent to factor
models. That is, suppose the data follows a factor model:</p>
<p><span class="math display">\[
X = F \Lambda^{*'} + e
\]</span> where</p>
<ul>
<li><p><span class="math inline">\(X\)</span> is a <span class="math inline">\(T \times n\)</span> data matrix, where there are
<span class="math inline">\(T\)</span> rows and <span class="math inline">\(n\)</span> variables, or columns</p></li>
<li><p><span class="math inline">\(F\)</span> is a <span class="math inline">\(T \times r\)</span> matrix of <span class="math inline">\(r\)</span> factors that the data is decomposed
into</p></li>
<li><p><span class="math inline">\(\Lambda^{*'}\)</span> is an <span class="math inline">\(r \times n\)</span> matrix of true
loadings</p></li>
<li><p><span class="math inline">\(e\)</span> is a <span class="math inline">\(T \times n\)</span> error matrix.</p></li>
</ul>
<p>Then, the assumption of sparsity in the loading matrix solves the
problem of rotational indeterminacy inherent to factor models: <span class="math inline">\(\Lambda^{*}\)</span> will be the most sparse
rotation and can be identified using the l1-rotation criterion <a href="https://simonfreyaldenhoven.github.io/papers/factor_rotation.pdf" class="external-link">Freyaldenhoven
(2025)</a>.</p>
</div>
<div class="section level2">
<h2 id="start">Quick start<a class="anchor" aria-label="anchor" href="#start"></a>
</h2>
<p>We will use the <code>example_data</code> data that ships with the
package to show its basic functionality. This data is a matrix
containing numeric information with <span class="math inline">\(n =
224\)</span>, <span class="math inline">\(T = 207\)</span>. In general,
data.frames, tibbles, or other data types can also be used with
<code>l1rotation</code> functions, as long as all columns are numeric.
Note that the package cannot handle missing values in the data
matrix.</p>
<p>To start, let’s look at the first seven columns of the example
data:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">example_data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">7</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;            V1       V2          V3         V4         V5          V6         V7</span></span>
<span><span class="co">#&gt; [1,] 2.973310 3.563021 -0.04496568 -0.1700720  0.3350881  0.05244918 -1.1922173</span></span>
<span><span class="co">#&gt; [2,] 4.648603 4.817172  0.11200137 -0.5456076  0.1992616  0.33365310 -1.1699467</span></span>
<span><span class="co">#&gt; [3,] 4.162014 3.169177 -1.37955943 -2.5864043 -2.9352645 -0.79856910 -1.7227167</span></span>
<span><span class="co">#&gt; [4,] 2.097454 0.833101 -2.72023404 -2.9061952 -2.7111563 -0.18925022 -1.5973617</span></span>
<span><span class="co">#&gt; [5,] 1.783429 0.364707 -2.24466997 -1.9397028 -0.2521484  1.14563662 -0.6416022</span></span>
<span><span class="co">#&gt; [6,] 5.699166 3.932394  0.46050753 -0.5615002  2.3014500  2.22261949  0.5748873</span></span></code></pre></div>
<p>We assume that the number of underlying factors can be learned from
the data (e.g., following the procedure in <a href="https://onlinelibrary.wiley.com/doi/epdf/10.1111/1468-0262.00273" class="external-link">Bai
and Ng (2002)</a> or <a href="https://onlinelibrary.wiley.com/doi/abs/10.3982/ECTA8968" class="external-link">Ahn and
Horenstein (2013)</a>). Note that this package does not include
functionality to calculate the number of factors - we simply take the
number of factors as a user input.</p>
<p>For the <code>example_data</code> we will use two factors. With just
the data, <span class="math inline">\(X\)</span>, and the number of
factors, <span class="math inline">\(r\)</span>, we can start estimating
the loadings with <code><a href="../reference/local_factors.html">local_factors()</a></code>. This function estimates
<span class="math inline">\(\Lambda^{*}\)</span> and provides helpful
diagnostics and figures.</p>
<p>Below is an example using <code>example_data</code> (note that
estimation can also be run in parallel with a selected number of cores,
<code>n_cores</code>):</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">916</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_factors.html">local_factors</a></span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="va">example_data</span>, r <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">FALSE</span>, n_cores <span class="op">=</span> <span class="cn">NULL</span> <span class="co"># Runs non-parallel by default</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In the estimation, the only required arguments for
<code><a href="../reference/local_factors.html">local_factors()</a></code> are the data to be and the number of
factors. We use the principal components estimator as the initial
estimate of the loadings, <span class="math inline">\(\Lambda^0\)</span>, which can be accessed via the
<code>initial_loadings</code> item of the output. The function also
computes a quick diagnostic to check whether local factors are present
in the data which is given in the output item
<code>has_local_factors</code>.</p>
<p>Additionally, there are several rotation diagnostics accessible via
<code>rotation_diagnostics</code>: (1) The rotation matrix, <span class="math inline">\(R\)</span>, that when multiplied by <span class="math inline">\(\Lambda^0\)</span> produces <span class="math inline">\(\hat{\Lambda}^*\)</span>, (2) the value of the l1
norm for each vector, and (3) the frequency with which the minimization
problem converges at each of the estimated loading vectors.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">rotation_diagnostics</span></span>
<span><span class="co">#&gt; $R</span></span>
<span><span class="co">#&gt;             R          </span></span>
<span><span class="co">#&gt; V1  0.7011144 0.8388980</span></span>
<span><span class="co">#&gt; V2 -0.7130488 0.5442886</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $fval</span></span>
<span><span class="co">#&gt; [1] 145.705 149.850</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sol_frequency</span></span>
<span><span class="co">#&gt; [1] 259 241</span></span></code></pre></div>
<p>For a visual interpretation of this rotation, we provide tile plots
contrasting the initial estimate <span class="math inline">\(\Lambda^0\)</span>, <code>pc_plot</code> and the
rotated estimate, <span class="math inline">\(\hat{\Lambda}^*\)</span>,
<code>rotated_plot</code>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">pc_plot</span></span></code></pre></div>
<p><img src="documentation_files/figure-html/unnamed-chunk-5-1.png" width="480" style="display: block; margin: auto;"></p>
<p>In the initial principal component estimate, recall that each factor
is simply a principal component. Of the 207 variables in <span class="math inline">\(X\)</span>, the first factor loads most negatively
along the variables between 88 and 120, and slightly negatively almost
everywhere else. Along the second factor, there are positive loadings
between variables 122 and 207 and slightly negative to near-zero
loadings elsewhere. However, it may be difficult to interpret the
relationship between variables and factors when all loadings are
nonzero.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">rotated_plot</span></span></code></pre></div>
<p><img src="documentation_files/figure-html/unnamed-chunk-6-1.png" width="480" style="display: block; margin: auto;"></p>
<p>The second estimate is a rotated version of loading matrix optimized
for sparsity using the l1-rotation criterion. This estimate is easier to
interpret as most variables between 90-207 load negatively on the first
factor, variables 0-120 load negatively on the second factor, and all
other loadings are close to zero.</p>
</div>
<div class="section level2">
<h2 id="details">Refining the details<a class="anchor" aria-label="anchor" href="#details"></a>
</h2>
<p><code>l1rotation</code> supplies two additional functions,
<code><a href="../reference/find_local_factors.html">find_local_factors()</a></code> and <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code>
which provide additional functionality to support the main
<code><a href="../reference/local_factors.html">local_factors()</a></code> function.</p>
<div class="section level3">
<h3 id="flf">
<code>find_local_factors()</code><a class="anchor" aria-label="anchor" href="#flf"></a>
</h3>
<p>This function takes the same inputs as <code><a href="../reference/local_factors.html">local_factors()</a></code>,
<code>X</code> and <code>r</code>, and has an additional argument,
<code>initial_loadings</code>, that allows the user to specify any
orthonormal basis of the loadings rather than defaulting to the
principal component estimator. Alternative initial estimates may include
Maximum Likelihood based estimation or Sparse Orthogonal Factor
Regression (<a href="http://faculty.marshall.usc.edu/yingying-fan/publications/IEEEIT-UFCLL19.pdf" class="external-link">Uematsu
et al. (2019)</a>), for example.</p>
</div>
<div class="section level3">
<h3 id="tlf">
<code>test_local_factors()</code><a class="anchor" aria-label="anchor" href="#tlf"></a>
</h3>
<p>This function tests for the presence of local factors given a sparse
basis of the loading space. It takes as input <code>X</code> and
<code>r</code>, and an additional optional argument,
<code>loadings</code>, that allows the user to specify the loading
matrix that is to be tested. This argument is set to <code>NULL</code>
by default, which estimates <span class="math inline">\(\hat{\Lambda}^*\)</span> (by maximizing the
l1-rotation criterion) and tests it for local factors.</p>
<p>To construct this diagnostic for a given loading matrix estimate,
<span class="math inline">\(\hat{\Lambda}\)</span>, we find the column
with the largest number of entries smaller than some threshold <span class="math inline">\(h_n\)</span>:</p>
<p><span class="math display">\[
\mathcal{L(\hat{\Lambda})} = \max_k\left(\sum_{i=1}^n
1\{\hat{|\lambda}_{ik}| &lt; h_n \}\right)
\]</span> We can then check whether the number of these “small” loadings
is larger than <span class="math inline">\(\gamma n\)</span></p>
<p><span class="math display">\[
\texttt{has_local_factors} = 1\{\mathcal{L}(\hat{\Lambda})  \geq \gamma
n \}.
\]</span></p>
<p>Returning to our <code>lf</code> results, we can take a look at the
value of <code>has_local_factors</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">has_local_factors</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>This value is the result of <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code>. To
verify, we can call <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code> on two different
estimates: the principal components estimate,
<code>initial_loadings</code>, and the l1rotation estimate,
<code>rotated_loadings</code>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Check for local factors in PC estimate...</span></span>
<span><span class="va">test_pc_estimate</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_local_factors.html">test_local_factors</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">example_data</span>, r <span class="op">=</span> <span class="fl">2</span>, loadings <span class="op">=</span> <span class="va">lf</span><span class="op">$</span><span class="va">initial_loadings</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># And rotated estimate</span></span>
<span><span class="va">test_rot_estimate</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_local_factors.html">test_local_factors</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">example_data</span>, r <span class="op">=</span> <span class="fl">2</span>, loadings <span class="op">=</span> <span class="va">lf</span><span class="op">$</span><span class="va">rotated_loadings</span><span class="op">)</span></span>
<span></span>
<span><span class="va">test_pc_estimate</span><span class="op">$</span><span class="va">has_local_factors</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="va">test_rot_estimate</span><span class="op">$</span><span class="va">has_local_factors</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Thus, no local factors are detected using the principal components
estimate, while the rotated estimate reveals two local factors. We can
also visualize the number of small loadings using the
<code>small_loadings_plot</code> element in our `lf’ results:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">round_hn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">test_rot_estimate</span><span class="op">$</span><span class="va">h_n</span>, digits <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lf</span><span class="op">$</span><span class="va">small_loadings_plot</span> <span class="op">+</span> </span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span></span>
<span>    title <span class="op">=</span> <span class="st">'Number of "small" loadings per factor'</span>, </span>
<span>    caption <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">'"Small" is defined as loadings less than'</span>, <span class="va">round_hn</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p><img src="documentation_files/figure-html/unnamed-chunk-9-1.png" width="480" style="display: block; margin: auto;"></p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Simon Freyaldenhoven, Ryan Kobler.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
