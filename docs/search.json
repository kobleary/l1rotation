[{"path":"https://kobleary.github.io/l1rotation/articles/application.html","id":"macroeconomic-indicators","dir":"Articles","previous_headings":"","what":"Macroeconomic Indicators","title":"Application","text":"Let’s now apply l1rotation package large panel US macroeconomic indicators. dataset FRED_QD data collected maintained Michael W. McCracken available . final sample also used paper can found local_factors.zip . Let’s read . Following Bai Ng, data 8 factors. get idea information data conveys, can categorize outcome variable one 14 groups :  Grouping variables panel US macroeconomic indicators, Freyaldenhoven (2025) Now, let’s try estimate 8 local factors.  plot , first factor corresponds group 6 corresponds price variables - suggesting interpretation factor price index. second factor mainly affects interest rates, employment indicators, industrial production third factor affects household balance sheets stock markets. picture somewhat less clear factors 4-8. Although picture somewhat less clear terms interpretation, can still see diagnostic checking whether local factors exist decreases \\(k\\) increases.","code":"library(l1rotation)  fred <- read.csv(file.path(me, \"fred.csv\"), header = FALSE) dim(fred) #> [1] 206 166 head(fred[,1:7]) #>         V1      V2       V3       V4       V5        V6      V7 #> 1 -0.93618 1.35640 -0.95510 -1.06600 -0.72831  1.163400 1.21780 #> 2 -0.48721 0.17344 -0.16558  0.68259  0.45872  1.285800 1.03640 #> 3  1.96610 1.82430  2.02730  0.91550  0.95781 -0.041807 0.85503 #> 4  0.30228 1.77050  0.97072 -1.48240 -1.31120  0.487860 1.94340 #> 5  1.27660 1.14510  1.49440  0.41494  0.11338  0.385080 0.67363 #> 6 -0.84318 0.75985 -0.78434  0.79395  0.84148  0.226120 0.31084 set.seed(916)  fred_lf <- local_factors(fred, 8) #> Finding rotations ■■■                                7% | ETA: 43s #> Finding rotations ■■■■■■■                           20% | ETA: 38s #> Finding rotations ■■■■■■■■■                         26% | ETA: 36s #> Finding rotations ■■■■■■■■■■■                       32% | ETA: 32s #> Finding rotations ■■■■■■■■■■■■■                     39% | ETA: 29s #> Finding rotations ■■■■■■■■■■■■■■■                   46% | ETA: 25s #> Finding rotations ■■■■■■■■■■■■■■■■■                 53% | ETA: 22s #> Finding rotations ■■■■■■■■■■■■■■■■■■■               59% | ETA: 19s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■             66% | ETA: 16s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■           72% | ETA: 13s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■          78% | ETA: 10s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■        85% | ETA:  7s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■      90% | ETA:  5s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    96% | ETA:  2s  variable_groups <- c(15, 27, 61, 69, 75, 109,                      115, 128, 137, 143, 147, 148, 154)  fred_lf$rotated_plot +   ggplot2::geom_hline(yintercept = variable_groups, lty = \"longdash\") fred_lf$small_loadings_plot"},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"intro","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started","text":"l1rotation package offers functionality estimate loadings matrix factor models based l1-rotation criterion following Freyaldenhoven (2025). key idea estimator assuming sparsity pattern loadings matrix solves problem rotational indeterminacy inherent factor models. Factor models take form \\[ X = F \\Lambda^{*'} + e \\] \\(X\\) \\(T \\times n\\) data matrix, \\(T\\) rows \\(n\\) variables, columns \\(F\\) \\(T \\times r\\) matrix \\(r\\) factors data decomposed \\(\\Lambda^{*'}\\) \\(r \\times n\\) matrix true loadings \\(e\\) \\(T \\times n\\) error matrix. package designed identify estimate \\(\\Lambda^{*}\\) subject additional sparsity assumptions detailed Freyaldenhoven (2025).","code":"library(l1rotation)"},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"start","dir":"Articles","previous_headings":"","what":"Quick start","title":"Getting Started","text":"use example_data data ships package show basic functionality. data matrix containing numeric information \\(n = 224\\), \\(T = 207\\). general, data.frames, tibbles, data types can also used l1rotation functions, long columns numeric. Note also package handle missing values data matrix. start, let’s look first seven columns example data: assume number underlying factors can learned data (following procedure Bai Ng (2002)). example_data use two factors. just data, \\(X\\), number factors, \\(r\\), can start estimating loadings local_factors(). function estimates \\(\\Lambda^{*}\\) provides helpful diagnostics figures. example using example_data (note estimation can also run parallel selected number cores, n_cores): estimation, local_factors() reasonable defaults set required arguments data ’re decomposing number factors. use principal components estimator initial estimate loadings, \\(\\Lambda_0\\), can accessed via Lambda0 item output. function also computes quick diagnostic check whether local factors present data given output item has_local_factors. Additionally, several rotation diagnostics accessible via rotation_diagnostics give rotation matrix, \\(R\\) multiplied \\(\\Lambda_0\\) produces \\(\\hat{\\Lambda}^*\\), value l1 norm vector, frequency solution appears initial grid estimates. visual interpretation rotation, provide tile plots contrasting initial estimate \\(\\Lambda_0\\), pc_plot rotated estimate, \\(\\hat{\\Lambda}^*\\), rotated_plot.  initial principal component estimate, recall factor simply principal component. 207 variables \\(X\\), first factor loads negatively along variables 90 120, slightly negatively almost everywhere else. Along second factor, positive loadings variables 125 200 slightly negative loadings elsewhere. However, may difficult interpret relationship variables factors loadings nonzero.  second estimate rotated version principal components estimator optimized sparsity. rotate vector principal components loadings matrix finds set factors sparse possible. can see, second plot may provide stronger interpretation variables 90-200 load negatively first factor variables 0-120 load negatively second factor. loadings along variables close zero, suggesting relationship. rotation, can easily identify sets variables related latent factors due revealed sparsity pattern.","code":"head(example_data[,1:7]) #>            V1       V2          V3         V4         V5          V6         V7 #> [1,] 2.973310 3.563021 -0.04496568 -0.1700720  0.3350881  0.05244918 -1.1922173 #> [2,] 4.648603 4.817172  0.11200137 -0.5456076  0.1992616  0.33365310 -1.1699467 #> [3,] 4.162014 3.169177 -1.37955943 -2.5864043 -2.9352645 -0.79856910 -1.7227167 #> [4,] 2.097454 0.833101 -2.72023404 -2.9061952 -2.7111563 -0.18925022 -1.5973617 #> [5,] 1.783429 0.364707 -2.24466997 -1.9397028 -0.2521484  1.14563662 -0.6416022 #> [6,] 5.699166 3.932394  0.46050753 -0.5615002  2.3014500  2.22261949  0.5748873 set.seed(916)  lf <- local_factors(   X = example_data, r = 2,   parallel = FALSE, n_cores = NULL # Runs non-parallel by default ) lf$rotation_diagnostics #> $R #>             R           #> V1  0.7011144 0.8388980 #> V2 -0.7130488 0.5442886 #>  #> $fval #> [1] 145.705 149.850 #>  #> $sol_frequency #> [1] 259 241 lf$pc_plot lf$rotated_plot"},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"details","dir":"Articles","previous_headings":"","what":"Refining the details","title":"Getting Started","text":"l1rotation supplies two additional functions, find_local_factors() test_local_factors() provide additional functionality support main local_factors() function.","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"flf","dir":"Articles","previous_headings":"Refining the details","what":"find_local_factors()","title":"Getting Started","text":"function additional argument, Lambda0, allows user specify orthonormal basis loadings rather defaulting principal component estimator. plausible alternative initial estimates: MLE estimation Sparse Orthogonal Factor Regression (SOFAR) Uematsu et al. (2019).","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"tlf","dir":"Articles","previous_headings":"Refining the details","what":"test_local_factors()","title":"Getting Started","text":"function tests presence local factors given estimate loadings matrix, Lambda. Since results package rely upon sparsity pattern true loadings matrix, test_local_factors() provides simple diagnostic check assumption. given loading matrix estimate, \\(\\hat{\\Lambda}\\), can consider maximizing across factors number individual loadings \\(\\hat{\\Lambda}\\) smaller threshold \\(h_n\\). gives us idea many “small” loadings \\(\\hat{\\Lambda}\\): \\[ \\mathcal{L(\\hat{\\Lambda})} = \\max_k\\left(\\sum_{=1}^n 1\\{\\hat{|\\lambda}_{ik}| < h_n \\}\\right) \\] number, can check whether number “small” loadings larger \\(\\gamma n\\) \\[ \\texttt{has_local_factors} = 1\\{\\mathcal{L}(\\hat{\\Lambda})  \\geq \\gamma n \\}. \\] Returning lf results, can take look value has_local_factors. value result test_local_factors(). verify, can call test_local_factors() two different estimates: principal components estimate, Lambda0, l1rotation estimate, Lambda. confirms local factors detected principal components estimate (sparsity pattern observed), local factors present rotated estimate. Note rotating initial estimate, optimizing sparsity, guaranteed produce sparse loadings matrix true loadings matrix sparse. However, sparsity pattern exist true loadings matrix, procedure recover .  Finally, given testing plot , can conclude factors 1 2 likely local since enough “small” loadings (.e., smaller value \\(h_n = 1/\\log(n) =\\) 0.188 example_data).","code":"lf$has_local_factors #> [1] TRUE # Check for local factors in PC estimate... test_pc_estimate <- test_local_factors(X = example_data, r = 2, loadings = lf$initial_loadings)  # And rotated estimate test_rot_estimate <- test_local_factors(X = example_data, r = 2, loadings = lf$rotated_loadings)  test_pc_estimate$has_local_factors #> [1] FALSE test_rot_estimate$has_local_factors #> [1] TRUE round_hn <- round(test_rot_estimate$h_n, digits = 3)  lf$small_loadings_plot +    ggplot2::labs(     title = 'Number of \"small\" loadings per factor',      caption = paste('\"Small\" is defined as loadings less than', round_hn)   )"},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"factor-models-primer","dir":"Articles","previous_headings":"","what":"Factor Models Primer","title":"Background and Intuition","text":"Factor models seek distill often high dimensional data set underlying latent factors capture much original variation data. say data, \\(X\\), follows factor structure : \\[ \\begin{align} \\underset{(T \\times n)}{X} = \\underset{(T \\times r)}{F} \\underset{(r \\times n)}{\\Lambda^{*'}}  + \\underset{(T \\times n)}{e} \\end{align} \\] \\(T\\) rows (observations), \\(n\\) columns (variables), \\(r\\) factors. can refer \\(\\lambda_{ik}^*\\) entry \\(\\Lambda^{*}\\) \\(\\)th row \\(k\\)th column \\(\\lambda_{ik}^*\\) shows factor \\(k\\) related , “loads onto,” variable \\(\\). Note \\(k\\)th column \\(\\Lambda^*\\) referred \\(\\lambda_k^*\\). Since \\(r\\) can learned data (following procedure Bai Ng (2002)) can assume \\(r\\) known. Next, ’re interested estimating true set factors \\(F\\), compress data fewer columns, true loadings \\(\\Lambda^*\\), show factors related original columns.","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"problem-rotational-indeterminacy","dir":"Articles","previous_headings":"","what":"Problem: Rotational Indeterminacy","title":"Background and Intuition","text":"However, unique estimate \\(F\\) estimate \\(\\Lambda^*\\) satisfies equation . fact, infinitely many . referred rotational indeterminacy issue makes interpretation loadings matrix tricky. see problem, let \\(H\\) nonsingular \\(r \\times r\\) matrix. can define estimate \\(\\Lambda^0 = \\Lambda^* (H')^{-1}\\) \\(F^0 = FH\\). tells us \\[ \\begin{align} X & = F^0 \\Lambda^{0'} \\\\ & = FH (H^{-1'})' \\Lambda^{*'}\\\\ & = FH H^{-1} \\Lambda^{*'} \\\\ & = F \\Lambda^{*'} \\end{align} \\] Hence \\(X = F^0\\Lambda^{0'} = F\\Lambda^*\\) can explained identically well “rotation” \\(H\\) true loadings factors. arbitrary rotation \\(H\\) corresponds different seemingly valid decomposition \\(X\\) provides alternate interpretation factors variables related. interested true relationship, \\(\\Lambda^*\\). can recover true interpretation?","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"solution-use-sparsity","dir":"Articles","previous_headings":"","what":"Solution: Use Sparsity","title":"Background and Intuition","text":"key idea Freyaldenhoven (2025) assuming sparsity pattern true loadings matrix \\(\\Lambda^*\\) solves issue rotational indeterminacy since sparsity pattern invariant rotations. Intuitively, rotation (linear combination) sparse loading vector less sparse. general, PCA can obtain estimates linear combination true loadings vectors. , can obtain principal component vectors columns \\(\\Lambda^0\\) \\[ \\begin{align} \\Lambda^0 = \\Lambda^*(H^{-1})' + \\epsilon \\end{align} \\] \\(H\\) . Therefore, since \\(\\Lambda^0\\) linear combination \\(\\Lambda^*\\), \\(\\Lambda^*\\) also equal linear combination \\(\\Lambda^0\\). linear combinations sparse loadings generally dense, must linear combination \\(\\Lambda^0\\) sparse. can use sparse linear combination \\(\\Lambda^0\\) estimator \\(\\Lambda^*\\). Assuming true loadings sparse fairly reasonable, particularly ’re interested factors thought affect subset original columns (.e., local factors). types factors common economic applications.","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"recovering-sparsity","dir":"Articles","previous_headings":"","what":"Recovering Sparsity","title":"Background and Intuition","text":"Now, find sparse linear combination loading vectors? steps : Take principal components estimator starting point obtain \\(\\Lambda^0\\) Find loadings \\(\\Lambda^*\\) equal rotation \\(\\Lambda^0\\) minimizes number non-zero elements (\\(l_0\\) norm) loading vectors Unfortunately, \\(l_0\\) norm infeasible optimize practice. see , let’s examine figure . distance origin red point depicts \\(l_0\\) norm points along unit circle. blue points depict \\(l_1\\) norm gray points depict \\(l_2\\) norm. \\(l_2\\) case, distances remain constant traverse circle.  Geometric Intuition Various Norms \\(l_0\\) norm directly computes number nonzero elements, shown red points (1, 0), (0, 1), (-1, 0) (0, -1) distance 1 away origin. remaining red points distance 2 away origin corresponding 2 nonzero elements points along unit circle. Since blue red dots coincide four points, \\(l_1\\) norm minimized points \\(l_0\\) norm. \\(l_1\\) norm much smoother descent minima compared discontinuities occur red points. smooth function easier traverse optimize . throughout, ’ll continue maximize sparsity indirectly easily using \\(l_1\\) norm instead \\(l_0\\) norm optimization benefits. Formally, using \\(l_1\\) norm, objective function becomes \\[ \\begin{align} \\min_R ||\\Lambda^0R||_1 \\end{align} \\] \\(R\\) nonsingular \\(||r_k||_2 = 1\\) \\(r_k\\) row \\(R\\). keeps length loading vector fixed, ensuring look rotations initial loading vector. Since length remains constant, can transform constrained optimization problem unconstrained one converting polar coordinates. case two factors, constrained version want find weights \\(w_1, w_2\\) minimize \\[ || w_1 \\lambda_1^0 + w_2 \\lambda_2^0 ||_1 \\quad s.t. \\quad w_1^2 + w_2^2 = 1. \\] spherical coordinates, amounts finding angle \\(\\theta\\) minimizes \\[ ||\\lambda_1^0 \\cos \\theta + \\lambda_2^0 \\sin \\theta ||_1. \\] unconstrained objective function becomes slightly complicated general case two factors span higher dimensional space plane therefore need optimize across multiple angles. idea remains .","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"objective-function","dir":"Articles","previous_headings":"","what":"Objective Function","title":"Background and Intuition","text":"Formally, using \\(l_1\\) norm, objective function becomes \\[ \\begin{align} \\min_R ||\\Lambda^0R||_1 \\end{align} \\] \\(R\\) nonsingular \\(||r_k||_2 = 1\\) \\(r_k\\) row \\(R\\). keeps length loading vector fixed, ensuring look rotations initial loading vector. Since length remains constant, can transform constrained optimization problem unconstrained one converting polar coordinates. case two factors, constrained version want find weights \\(w_1, w_2\\) minimize \\[ || w_1 \\lambda_1^0 + w_2 \\lambda_2^0 ||_1 \\quad s.t. \\quad w_1^2 + w_2^2 = 1. \\] spherical coordinates, amounts finding angle \\(\\theta\\) minimizes \\[ ||\\lambda_1^0 \\cos \\theta + \\lambda_2^0 \\sin \\theta ||_1. \\] unconstrained objective function becomes slightly complicated general case two factors span higher dimensional space plane therefore need optimize across multiple angles. idea remains .","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"a-simple-example","dir":"Articles","previous_headings":"","what":"A simple example","title":"Background and Intuition","text":"Let’s consider example can visualize fully: ’ll use following simulated data three columns (\\(n = 3\\)) suppose know two factors, \\(r = 2\\). first 6 224 total rows printed. Let true loadings matrix, \\(\\Lambda^*\\) 2 columns 3 rows. can see sparsity pattern matrix first factor affecting first column second factor affecting second third columns \\(X\\). Now, let’s look PCA estimator \\(X\\) first two principal components. zeroes longer present, principal component estimate still provides great starting point generally linear combinations true loading vectors \\(n \\\\infty\\) (cite). Let’s try get clearer picture far visualizing components. interactive visualization data points, \\(X\\) plane spanned principal component vectors (blue plane) principal component vectors \\(\\Lambda^0\\) (blue) true loading vectors \\(\\Lambda^*\\) (orange) can see, blue principal component vectors span blue plane. definition, two vectors provide directions maximal variance data. can also imagine data cloud projected onto plane give us sense data compressed 3 2 dimensions. Notice blue vectors nowhere near true loading vectors shown orange. However, simply rotating blue vectors give us solutions closer true vectors. Using sliders control angle rotation vector separately, try rotating blue vectors along plane find rotation lines close possible orange vectors. Since \\(n = 3\\) small, can see noise PC estimate, resulting loading vectors located slightly plane. Still, can get better estimate true vectors rotating. try different angles rotation can see impact objective function ’re optimizing . rotation best aligns true loadings vectors also occur local minima objective function. visualizations show relationship angles rotation, objective function optimizing sparsity, position vectors space relative true loadings. crux intuition behind research accompanying package.","code":"V1         V2         V3 1  0.4814018  0.7468954 -1.4401043 2 -0.8309668 -0.6558851  1.5983829 3  0.2360548  0.8199547  1.8496925 4  0.3685305  0.9678467 -1.1387934 5 -0.5266293  0.3336697 -0.0650335 6 -0.2464255 -0.5563491  0.8534258 loadings_1 loadings_2 1   1.024946  0.0000000 2   0.000000  1.3517553 3   0.000000  0.2765392 loadings_1 loadings_2 1 -1.2668929 -0.2153919 2 -0.8709413 -0.9799329 3  0.7977743 -1.4118561 math = require('https://cdnjs.cloudflare.com/ajax/libs/mathjs/1.5.2/math.min.js') d3 = require(\"d3@3\")  THREE = {   const THREE = window.THREE = await require(\"three@0.130.0/build/three.min.js\");   await require(\"three@0.130.0/examples/js/controls/OrbitControls.js\").catch(() => {});   return THREE; } renderer.domElement viewof theta1_value = Inputs.range(   [-3.13, 3.13],    {value: 0, step: .01, label: \"Vector 1 angle (θ):\"} )  viewof theta2_value = Inputs.range(   [-3.13, 3.13],    {value: 1.57, step: .01, label: \"Vector 2 angle (θ):\"} ) highlighted_points = obj_data.filter(function(angle) {   return (theta1_value - 0.005 < angle.theta && theta1_value + 0.005 > angle.theta) ||          (theta2_value - 0.005 < angle.theta && theta2_value + 0.005 > angle.theta) })  obj_data = FileAttachment(\"obj_function_data.csv\").csv({typed: true});  Plot.plot({   height: 150,   width: 700,   grid: true,   marks: [     Plot.dot(obj_data, {       x: \"theta\",        y: \"y\",       r: 1     }),     Plot.dot(highlighted_points, {       x: \"theta\",        y: \"y\",        fill: \"#0000FF\",        r: 5     })   ],   x: {   label: \"θ\" },   y: {     label: \"\"   },   title: \"Objective function: ||λ₁⁰ cos θ + λ₂⁰ sin θ ||₁\",   style: {     background: \"transparent\",     fontSize: 12   } }) height = 450; camera = {   const fov = 45;   const aspect = width / height;   const near = 1;   const far = 1000;   const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);   camera.position.set(-2*2, 2*2, -2*2)   camera.lookAt(new THREE.Vector3(0, 0, 0));   return camera; }  gridHelper = {const size = 10; const divisions = 10;  const gridHelper = new THREE.GridHelper( size, divisions ); return gridHelper; }  renderer = {   const renderer = new THREE.WebGLRenderer({antialias: true});   renderer.setSize(width, height);   renderer.setPixelRatio(devicePixelRatio);   const controls = new THREE.OrbitControls(camera, renderer.domElement);   controls.addEventListener(\"change\", () => renderer.render(scene, camera));   invalidation.then(() => (controls.dispose(), renderer.dispose()));   return renderer; } pca_vectors = await FileAttachment('lambda0.csv').csv({typed: true}) true_vectors = await FileAttachment('truth_normal.csv').csv({typed: true})   display_arrow = {const dir = new THREE.Vector3( pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          display_arrow2 = {const dir = new THREE.Vector3( pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                   true_vector1 = {const dir = new THREE.Vector3( true_vectors[0].V1, true_vectors[1].V1, true_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          true_vector2 = {const dir = new THREE.Vector3( true_vectors[0].V2, true_vectors[1].V2, true_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                     math_plane = {   const v1 = new THREE.Vector3(pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);   const v2 = new THREE.Vector3(pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);   const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();      // Create a plane with normal   const plane = new THREE.Plane(normal);      // Create a PlaneGeometry (size 4x4 units, with sufficient segments)   const planeGeometry = new THREE.PlaneGeometry(4, 4, 1, 1);      // Create a material with transparency   const planeMaterial = new THREE.MeshBasicMaterial({     color: 0x6495ED,      transparent: true,     opacity: 0.5,     // 50% opacity, adjust as needed     side: THREE.DoubleSide // Visible from both sides   });      // Create the mesh   const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);      // Position and orient the plane correctly   // First, find a point on the plane (using the plane equation)   const pointOnPlane = new THREE.Vector3();   // You can set this to origin or any other point you prefer   plane.projectPoint(new THREE.Vector3(0, 0, 0), pointOnPlane);      // Set the position   planeMesh.position.copy(pointOnPlane);      // Orient the plane to match your normal vector   planeMesh.lookAt(pointOnPlane.clone().add(normal));      // Store both the plane object (for calculations) and the mesh (for display)   return {     plane: plane,     mesh: planeMesh   }; }   points = {   const data = await FileAttachment('data.csv').csv({typed: true});   const geometry = new THREE.BufferGeometry();   const positions = new Float32Array(data.flatMap(d => [d.V1, d.V2, d.V3]));   geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));    const material = new THREE.PointsMaterial({color: 0x000000, size: 0.1});   const points = new THREE.Points(geometry, material);   return points; } scene = {   const scene = new THREE.Scene();   scene.background = new THREE.Color(0xffffff);   scene.add(gridHelper);   scene.add(display_arrow);   scene.add(display_arrow2);   scene.add(true_vector1);   scene.add(true_vector2);   scene.add(math_plane.mesh);   scene.add(points);   return scene; }  update1 = {   // For the first vector v1   const x1 = Math.cos(theta1_value);   const y1 = Math.sin(theta1_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x1 * pca_vectors[0].V1 + y1 * pca_vectors[0].V2,     x1 * pca_vectors[1].V1 + y1 * pca_vectors[1].V2,     x1 * pca_vectors[2].V1 + y1 * pca_vectors[2].V2   ).normalize();      display_arrow.setDirection(new_direction);   renderer.render(scene, camera);   return; }  update2 = {   // For the first vector v1   const x2 = Math.cos(theta2_value);   const y2 = Math.sin(theta2_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x2 * pca_vectors[0].V1 + y2 * pca_vectors[0].V2,     x2 * pca_vectors[1].V1 + y2 * pca_vectors[1].V2,     x2 * pca_vectors[2].V1 + y2 * pca_vectors[2].V2   ).normalize();      display_arrow2.setDirection(new_direction);   renderer.render(scene, camera);   return; }"},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"interactive-visualization","dir":"Articles","previous_headings":"","what":"Interactive Visualization","title":"Background and Intuition","text":"can see, blue principal component vectors span blue plane. definition, two vectors provide directions maximal variance data. can also imagine data cloud projected onto plane give us sense data compressed 3 2 dimensions. Notice blue vectors nowhere near true loading vectors shown orange. However, simply rotating blue vectors give us solutions closer true vectors. Using sliders control angle rotation vector separately, try rotating blue vectors along plane find rotation lines close possible orange vectors. Since \\(n = 3\\) small, can see noise PC estimate, resulting loading vectors located slightly plane. Still, can get better estimate true vectors rotating. try different angles rotation can see impact objective function ’re optimizing . rotation best aligns true loadings vectors also occur local minima objective function. visualizations show relationship angles rotation, objective function optimizing sparsity, position vectors space relative true loadings. crux intuition behind research accompanying package.","code":"math = require('https://cdnjs.cloudflare.com/ajax/libs/mathjs/1.5.2/math.min.js') d3 = require(\"d3@3\")  THREE = {   const THREE = window.THREE = await require(\"three@0.130.0/build/three.min.js\");   await require(\"three@0.130.0/examples/js/controls/OrbitControls.js\").catch(() => {});   return THREE; } renderer.domElement viewof theta1_value = Inputs.range(   [-3.13, 3.13],    {value: 0, step: .01, label: \"Vector 1 angle (θ):\"} )  viewof theta2_value = Inputs.range(   [-3.13, 3.13],    {value: 1.57, step: .01, label: \"Vector 2 angle (θ):\"} ) highlighted_points = obj_data.filter(function(angle) {   return (theta1_value - 0.005 < angle.theta && theta1_value + 0.005 > angle.theta) ||          (theta2_value - 0.005 < angle.theta && theta2_value + 0.005 > angle.theta) })  obj_data = FileAttachment(\"obj_function_data.csv\").csv({typed: true});  Plot.plot({   height: 150,   width: 700,   grid: true,   marks: [     Plot.dot(obj_data, {       x: \"theta\",        y: \"y\",       r: 1     }),     Plot.dot(highlighted_points, {       x: \"theta\",        y: \"y\",        fill: \"#0000FF\",        r: 5     })   ],   x: {   label: \"θ\" },   y: {     label: \"\"   },   title: \"Objective function: ||λ₁⁰ cos θ + λ₂⁰ sin θ ||₁\",   style: {     background: \"transparent\",     fontSize: 12   } }) height = 450; camera = {   const fov = 45;   const aspect = width / height;   const near = 1;   const far = 1000;   const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);   camera.position.set(-2*2, 2*2, -2*2)   camera.lookAt(new THREE.Vector3(0, 0, 0));   return camera; }  gridHelper = {const size = 10; const divisions = 10;  const gridHelper = new THREE.GridHelper( size, divisions ); return gridHelper; }  renderer = {   const renderer = new THREE.WebGLRenderer({antialias: true});   renderer.setSize(width, height);   renderer.setPixelRatio(devicePixelRatio);   const controls = new THREE.OrbitControls(camera, renderer.domElement);   controls.addEventListener(\"change\", () => renderer.render(scene, camera));   invalidation.then(() => (controls.dispose(), renderer.dispose()));   return renderer; } pca_vectors = await FileAttachment('lambda0.csv').csv({typed: true}) true_vectors = await FileAttachment('truth_normal.csv').csv({typed: true})   display_arrow = {const dir = new THREE.Vector3( pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          display_arrow2 = {const dir = new THREE.Vector3( pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                   true_vector1 = {const dir = new THREE.Vector3( true_vectors[0].V1, true_vectors[1].V1, true_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          true_vector2 = {const dir = new THREE.Vector3( true_vectors[0].V2, true_vectors[1].V2, true_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                     math_plane = {   const v1 = new THREE.Vector3(pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);   const v2 = new THREE.Vector3(pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);   const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();      // Create a plane with normal   const plane = new THREE.Plane(normal);      // Create a PlaneGeometry (size 4x4 units, with sufficient segments)   const planeGeometry = new THREE.PlaneGeometry(4, 4, 1, 1);      // Create a material with transparency   const planeMaterial = new THREE.MeshBasicMaterial({     color: 0x6495ED,      transparent: true,     opacity: 0.5,     // 50% opacity, adjust as needed     side: THREE.DoubleSide // Visible from both sides   });      // Create the mesh   const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);      // Position and orient the plane correctly   // First, find a point on the plane (using the plane equation)   const pointOnPlane = new THREE.Vector3();   // You can set this to origin or any other point you prefer   plane.projectPoint(new THREE.Vector3(0, 0, 0), pointOnPlane);      // Set the position   planeMesh.position.copy(pointOnPlane);      // Orient the plane to match your normal vector   planeMesh.lookAt(pointOnPlane.clone().add(normal));      // Store both the plane object (for calculations) and the mesh (for display)   return {     plane: plane,     mesh: planeMesh   }; }   points = {   const data = await FileAttachment('data.csv').csv({typed: true});   const geometry = new THREE.BufferGeometry();   const positions = new Float32Array(data.flatMap(d => [d.V1, d.V2, d.V3]));   geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));    const material = new THREE.PointsMaterial({color: 0x000000, size: 0.1});   const points = new THREE.Points(geometry, material);   return points; } scene = {   const scene = new THREE.Scene();   scene.background = new THREE.Color(0xffffff);   scene.add(gridHelper);   scene.add(display_arrow);   scene.add(display_arrow2);   scene.add(true_vector1);   scene.add(true_vector2);   scene.add(math_plane.mesh);   scene.add(points);   return scene; }  update1 = {   // For the first vector v1   const x1 = Math.cos(theta1_value);   const y1 = Math.sin(theta1_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x1 * pca_vectors[0].V1 + y1 * pca_vectors[0].V2,     x1 * pca_vectors[1].V1 + y1 * pca_vectors[1].V2,     x1 * pca_vectors[2].V1 + y1 * pca_vectors[2].V2   ).normalize();      display_arrow.setDirection(new_direction);   renderer.render(scene, camera);   return; }  update2 = {   // For the first vector v1   const x2 = Math.cos(theta2_value);   const y2 = Math.sin(theta2_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x2 * pca_vectors[0].V1 + y2 * pca_vectors[0].V2,     x2 * pca_vectors[1].V1 + y2 * pca_vectors[1].V2,     x2 * pca_vectors[2].V1 + y2 * pca_vectors[2].V2   ).normalize();      display_arrow2.setDirection(new_direction);   renderer.render(scene, camera);   return; }"},{"path":"https://kobleary.github.io/l1rotation/articles/macro_application.html","id":"macroeconomic-indicators","dir":"Articles","previous_headings":"","what":"Macroeconomic Indicators","title":"Application","text":"Let’s now apply l1rotation package large panel US macroeconomic indicators, following one examples provided Freyaldenhoven (2025). dataset FRED_QD data collected maintained Michael W. McCracken available . specific example uses data 1967Q1-2019Q1 follows transformations recommended McCracken Ng (2016) remove outliers. aggregated data series dropped well. final cleaned sample used paper consists disaggregated stationary time series can found . information, see paper. Let’s read . Following Bai Ng, data 8 factors. get idea information data conveys, can categorize outcome variable one 14 groups :  Grouping variables panel US macroeconomic indicators, Freyaldenhoven (2025) Now, let’s try estimate 8 local factors.  plot , first factor corresponds group 6 corresponds price variables - suggesting interpretation factor price index. second factor mainly affects interest rates, employment indicators, industrial production third factor affects household balance sheets stock markets. picture somewhat less clear factors 4-8. Although picture somewhat less clear terms interpretation, can still see diagnostic checking whether local factors exist decreases \\(k\\) increases.","code":"library(l1rotation)  fred <- read.csv(file.path(me, \"fred.csv\"), header = FALSE) dim(fred) #> [1] 206 166 head(fred[,1:7]) #>         V1      V2       V3       V4       V5        V6      V7 #> 1 -0.93618 1.35640 -0.95510 -1.06600 -0.72831  1.163400 1.21780 #> 2 -0.48721 0.17344 -0.16558  0.68259  0.45872  1.285800 1.03640 #> 3  1.96610 1.82430  2.02730  0.91550  0.95781 -0.041807 0.85503 #> 4  0.30228 1.77050  0.97072 -1.48240 -1.31120  0.487860 1.94340 #> 5  1.27660 1.14510  1.49440  0.41494  0.11338  0.385080 0.67363 #> 6 -0.84318 0.75985 -0.78434  0.79395  0.84148  0.226120 0.31084 set.seed(916)  fred_lf <- local_factors(fred, 8) #> Finding rotations ■■■■                               9% | ETA: 44s #> Finding rotations ■■■■■■■                           21% | ETA: 40s #> Finding rotations ■■■■■■■■■                         25% | ETA: 39s #> Finding rotations ■■■■■■■■■■                        30% | ETA: 39s #> Finding rotations ■■■■■■■■■■■                       34% | ETA: 38s #> Finding rotations ■■■■■■■■■■■■■                     39% | ETA: 35s #> Finding rotations ■■■■■■■■■■■■■■                    43% | ETA: 33s #> Finding rotations ■■■■■■■■■■■■■■■■                  49% | ETA: 30s #> Finding rotations ■■■■■■■■■■■■■■■■■                 54% | ETA: 26s #> Finding rotations ■■■■■■■■■■■■■■■■■■■               60% | ETA: 22s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■             66% | ETA: 19s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■           73% | ETA: 15s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■         79% | ETA: 12s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■        84% | ETA:  9s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■      89% | ETA:  6s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    96% | ETA:  2s  variable_groups <- c(15, 27, 61, 69, 75, 109,                      115, 128, 137, 143, 147, 148, 154)  fred_lf$rotated_plot +   ggplot2::geom_hline(yintercept = variable_groups, lty = \"longdash\") fred_lf$small_loadings_plot"},{"path":"https://kobleary.github.io/l1rotation/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Simon Freyaldenhoven. Author, copyright holder. Ryan Kobler. Author, maintainer.","code":""},{"path":"https://kobleary.github.io/l1rotation/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Freyaldenhoven S, Kobler R (2025). “l1rotation package.” https://github.com/SimonFreyaldenhoven/l1rotation.","code":"@Misc{,   title = {l1rotation package},   author = {Simon Freyaldenhoven and Ryan Kobler},   url = {https://github.com/SimonFreyaldenhoven/l1rotation},   year = {2025}, }"},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"l1rotation package implements l1-rotation rotation criterion identify estimate loadings matrix factor models following Freyaldenhoven (2025).","code":""},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"","code":"# Install from CRAN install.packages(\"l1rotation\")  # Install latest version from GitHub install.packages(\"devtools\") devtools::install_github(\"SimonFreyaldenhoven/l1rotation\")"},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"Find minimal example . examples see package documentation vignette.","code":"library(l1rotation) set.seed(916)   # Minimal example with 4 factors, where X is a 224 by 207 matrix lf <- local_factors(X = example_data, r = 2)  # Rerun with parallel processing lf_lambdas <- find_local_factors(X = example_data, r = 2, parallel = TRUE, n_cores = 10)  # Visualize Principal Component estimate of the loadings lf$pc_plot # Visualize l1-rotation loadings lf$rotated_plot"},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"Simon Freyaldenhoven.”Identification Sparsity Factor Models: l1-rotation criterion” Working Paper, February 2025. Simon Freyaldenhoven, Ryan Kobler. “l1rotation package.” Code data repository https://github.com/SimonFreyaldenhoven/l1rotation, March 2025.","code":""},{"path":"https://kobleary.github.io/l1rotation/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 l1rotation authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data with four factors from the replication files of Freyaldenhoven et. al (2025). — example_data","title":"Example data with four factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"Example data four factors replication files Freyaldenhoven et. al (2025).","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data with four factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"","code":"example_data"},{"path":[]},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":"example-data","dir":"Reference","previous_headings":"","what":"example_data","title":"Example data with four factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"matrix 224 rows 207 columns.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example data with four factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"Dataset available .mat file can generated local_factors.zip https://simonfreyaldenhoven.github.io/software/","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"Find sparse rotation orthonormal basis loading space t n matrix X. Additional flexibility initial_loadings argument allows user specify orthonormal basis rather defaulting PCA.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"","code":"find_local_factors(X, r, initial_loadings, parallel = FALSE, n_cores = NULL)"},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"X (usually standardized) t n matrix observations. r integer denoting number factors X. initial_loadings Matrix represents orthonormal basis loading space. supplied, PCA used default function also local_factors. parallel logical denoting whether algorithm run parallel. n_cores integer denoting many cores used, parallel == TRUE.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"Returns list following components: initial_loadings Principal Component estimate loading matrix (supplied). rotated_loadings Matrix rotation loading matrix produces smallest l1-norm. rotation_diagnostics list containing 3 components: R Rotation matrix used rotate initial_loadings produces smallest l1-norm. l1_norm Vector length r containing value l1 norm solution generates. sol_frequency Vector length r containing frequency initial grid solution.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"","code":"# Minimal example with 2 factors, where X is a 224 by 207 matrix r <- 2 M <- nrow(example_data) n <- ncol(example_data)  # Compute PCA estimates basis <- svd(example_data / sqrt(M), nu = M, nv = n) initial_loadings <- sqrt(n) * basis$v[, 1:r]  # Find minimum rotation using orthonormal basis initial_loadings rotation_result <- find_local_factors(X = example_data, r = r, initial_loadings = initial_loadings)"},{"path":"https://kobleary.github.io/l1rotation/reference/l1rotation-package.html","id":null,"dir":"Reference","previous_headings":"","what":"l1rotation: Identify Loading Vectors under Sparsity in Factor Models — l1rotation-package","title":"l1rotation: Identify Loading Vectors under Sparsity in Factor Models — l1rotation-package","text":"Estimate loading vectors using l1 criterion proposed Freyaldenhoven (2025) https://simonfreyaldenhoven.github.io/papers/factor_rotation.pdf. Given data matrix, find rotation loading matrix smallest l1-norm /test presence local factors.","code":""},{"path":[]},{"path":"https://kobleary.github.io/l1rotation/reference/l1rotation-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"l1rotation: Identify Loading Vectors under Sparsity in Factor Models — l1rotation-package","text":"Maintainer: Ryan Kobler kobleary@gmail.com Authors: Simon Freyaldenhoven simon.freyaldenhoven@phil.frb.org [copyright holder]","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"local_factors tests whether local factors present returns Principal Component estimate loadings rotation loadings smallest l1-norm. also produces graphical illustrations results.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"","code":"local_factors(X, r, parallel = FALSE, n_cores = NULL)"},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"X (usually standardized) t n matrix observations. r integer denoting number factors X. parallel logical denoting whether algorithm run parallel. n_cores integer denoting many cores used, parallel == TRUE.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"Returns list following components: has_local_factors logical equal TRUE local factors present. initial_loadings Principal component estimate loading matrix. rotated_loadings Matrix rotation loading matrix produces smallest l1-norm. rotation_diagnostics list containing 3 components: R Rotation matrix used rotate initial_loadings produces smallest l1-norm. l1_norm Vector length r containing value l1 norm solution generates. sol_frequency Vector length r containing frequency initial grid solution. pc_plot Tile plot Principal Component estimate loading matrix. rotated_plot Tile plot l1-rotation loading matrix estimate. small_loadings_plot Plot number small loadings column l1-rotation loading matrix estimate.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"","code":"# Minimal example with 2 factors, where X is a 224 by 207 matrix lf <- local_factors(X = example_data, r = 2)  # Visualize Principal Component estimate of the loadings lf$pc_plot   # Visualize l1-rotation loadings lf$pc_rotated_plot #> NULL"},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"Test presence local factors, local_factors(), additional flexibility.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"","code":"test_local_factors(X, r, loadings = NULL)"},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"X (usually standardized) t n matrix observations. r integer denoting number factors X. loadings (optional) Matrix represents sparse basis loading space.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"Returns list following components: has_local_factors Logical equal TRUE local factors present. n_small Integer denoting number small loadings sparse rotation. gamma_n Integer denoting critical value compare n_small . h_n Number denoting cutoff used determine loadings small. loadings Matrix rotation loadings produces smallest l1-norm (supplied).","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"","code":"# Minimal example with 2 factors, where X is a 224 by 207 matrix r <- 2 M <- nrow(example_data) n <- ncol(example_data)  # Find minimum rotation rotation_result <- find_local_factors(X = example_data, r)  # Test if sparse basis has local factors test_result <- test_local_factors(    X = example_data,    r = r,    loadings = rotation_result$rotated_loadings )  test_result$has_local_factors #> [1] TRUE"},{"path":[]},{"path":"https://kobleary.github.io/l1rotation/news/index.html","id":"l1rotation-v002","dir":"Changelog","previous_headings":"","what":"l1rotation v0.0.2","title":"l1rotation v0.0.2","text":"Initial CRAN submission. Adds core functionality user functions local_factors(), find_local_factors(), test_local_factors() Updates arguments results loadings rather Lambda throughout","code":""}]
