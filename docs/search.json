[{"path":"https://kobleary.github.io/l1rotation/articles/application.html","id":"macroeconomic-indicators","dir":"Articles","previous_headings":"","what":"Macroeconomic Indicators","title":"Application","text":"Let’s now apply l1rotation package large panel US macroeconomic indicators. dataset FRED_QD data collected maintained Michael W. McCracken available . final sample also used paper can found local_factors.zip . Let’s read . Following Bai Ng, data 8 factors. get idea information data conveys, can categorize outcome variable one 14 groups :  Grouping variables panel US macroeconomic indicators, Freyaldenhoven (2025) Now, let’s try estimate 8 local factors.  plot , first factor corresponds group 6 corresponds price variables - suggesting interpretation factor price index. second factor mainly affects interest rates, employment indicators, industrial production third factor affects household balance sheets stock markets. picture somewhat less clear factors 4-8. Although picture somewhat less clear terms interpretation, can still see diagnostic checking whether local factors exist decreases \\(k\\) increases.","code":"library(l1rotation)  fred <- read.csv(file.path(me, \"fred.csv\"), header = FALSE) dim(fred) #> [1] 206 166 head(fred[,1:7]) #>         V1      V2       V3       V4       V5        V6      V7 #> 1 -0.93618 1.35640 -0.95510 -1.06600 -0.72831  1.163400 1.21780 #> 2 -0.48721 0.17344 -0.16558  0.68259  0.45872  1.285800 1.03640 #> 3  1.96610 1.82430  2.02730  0.91550  0.95781 -0.041807 0.85503 #> 4  0.30228 1.77050  0.97072 -1.48240 -1.31120  0.487860 1.94340 #> 5  1.27660 1.14510  1.49440  0.41494  0.11338  0.385080 0.67363 #> 6 -0.84318 0.75985 -0.78434  0.79395  0.84148  0.226120 0.31084 set.seed(916)  fred_lf <- local_factors(fred, 8) #> Finding rotations ■■■                                7% | ETA: 43s #> Finding rotations ■■■■■■■                           20% | ETA: 38s #> Finding rotations ■■■■■■■■■                         26% | ETA: 36s #> Finding rotations ■■■■■■■■■■■                       32% | ETA: 32s #> Finding rotations ■■■■■■■■■■■■■                     39% | ETA: 29s #> Finding rotations ■■■■■■■■■■■■■■■                   46% | ETA: 25s #> Finding rotations ■■■■■■■■■■■■■■■■■                 53% | ETA: 22s #> Finding rotations ■■■■■■■■■■■■■■■■■■■               59% | ETA: 19s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■             66% | ETA: 16s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■           72% | ETA: 13s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■          78% | ETA: 10s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■        85% | ETA:  7s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■      90% | ETA:  5s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    96% | ETA:  2s  variable_groups <- c(15, 27, 61, 69, 75, 109,                      115, 128, 137, 143, 147, 148, 154)  fred_lf$rotated_plot +   ggplot2::geom_hline(yintercept = variable_groups, lty = \"longdash\") fred_lf$small_loadings_plot"},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"intro","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started","text":"l1rotation package offers functionality simplify loading matrix factor models. can find sparse rotation loading matrix using l1-rotation criterion Freyaldenhoven (2025). assumption sparsity true loading matrix, also solves problem rotational indeterminacy inherent factor models. , suppose data follows factor model: \\[ X = F \\Lambda^{*'} + e \\] \\(X\\) \\(T \\times n\\) data matrix, \\(T\\) rows \\(n\\) variables, columns \\(F\\) \\(T \\times r\\) matrix \\(r\\) factors data decomposed \\(\\Lambda^{*'}\\) \\(r \\times n\\) matrix true loadings \\(e\\) \\(T \\times n\\) error matrix. , assumption sparsity loading matrix solves problem rotational indeterminacy inherent factor models: \\(\\Lambda^{*}\\) sparse rotation can identified using l1-rotation criterion Freyaldenhoven (2025).","code":"library(l1rotation)"},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"start","dir":"Articles","previous_headings":"","what":"Quick start","title":"Getting Started","text":"use example_data data ships package show basic functionality. data matrix containing numeric information \\(n = 224\\), \\(T = 207\\). general, data.frames, tibbles, data types can also used l1rotation functions, long columns numeric. Note package handle missing values data matrix. start, let’s look first seven columns example data: assume number underlying factors can learned data (e.g., following procedure Bai Ng (2002) Ahn Horenstein (2013)). Note package include functionality calculate number factors - simply take number factors user input. example_data use two factors. just data, \\(X\\), number factors, \\(r\\), can start estimating loadings local_factors(). function estimates \\(\\Lambda^{*}\\) provides helpful diagnostics figures. example using example_data (note estimation can also run parallel selected number cores, n_cores): estimation, required arguments local_factors() data decomposed number factors. use principal components estimator initial estimate loadings, \\(\\Lambda^0\\), can accessed via initial_loadings item output. function also computes quick diagnostic check whether local factors present data given output item has_local_factors. Additionally, several rotation diagnostics accessible via rotation_diagnostics: (1) rotation matrix, \\(R\\), multiplied \\(\\Lambda^0\\) produces \\(\\hat{\\Lambda}^*\\), (2) value l1 norm vector, (3) frequency minimization problem converges estimated loading vectors. visual interpretation rotation, provide tile plots contrasting initial estimate \\(\\Lambda^0\\), pc_plot rotated estimate, \\(\\hat{\\Lambda}^*\\), rotated_plot.  initial principal component estimate, recall factor simply principal component. 207 variables \\(X\\), first factor loads negatively along variables 90 120, slightly negatively almost everywhere else. Along second factor, positive loadings variables 122 207 slightly negative loadings elsewhere. However, may difficult interpret relationship variables factors loadings nonzero.  second estimate rotated version loading matrix optimized sparsity using l1-rotation criterion. estimate easier interpret variables 90-207 load negatively first factor, variables 0-120 load negatively second factor, loadings close zero.","code":"head(example_data[,1:7]) #>            V1       V2          V3         V4         V5          V6         V7 #> [1,] 2.973310 3.563021 -0.04496568 -0.1700720  0.3350881  0.05244918 -1.1922173 #> [2,] 4.648603 4.817172  0.11200137 -0.5456076  0.1992616  0.33365310 -1.1699467 #> [3,] 4.162014 3.169177 -1.37955943 -2.5864043 -2.9352645 -0.79856910 -1.7227167 #> [4,] 2.097454 0.833101 -2.72023404 -2.9061952 -2.7111563 -0.18925022 -1.5973617 #> [5,] 1.783429 0.364707 -2.24466997 -1.9397028 -0.2521484  1.14563662 -0.6416022 #> [6,] 5.699166 3.932394  0.46050753 -0.5615002  2.3014500  2.22261949  0.5748873 set.seed(916)  lf <- local_factors(   X = example_data, r = 2,   parallel = FALSE, n_cores = NULL # Runs non-parallel by default ) lf$rotation_diagnostics #> $R #>             R           #> V1  0.7011144 0.8388980 #> V2 -0.7130488 0.5442886 #>  #> $fval #> [1] 145.705 149.850 #>  #> $sol_frequency #> [1] 259 241 lf$pc_plot lf$rotated_plot"},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"details","dir":"Articles","previous_headings":"","what":"Refining the details","title":"Getting Started","text":"l1rotation supplies two additional functions, find_local_factors() test_local_factors() provide additional functionality support main local_factors() function.","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"flf","dir":"Articles","previous_headings":"Refining the details","what":"find_local_factors()","title":"Getting Started","text":"function takes inputs local_factors(), X r, additional argument, initial_loadings, allows user specify orthonormal basis loadings rather defaulting principal component estimator. Alternative initial estimates may include Maximum Likelihood based estimation Sparse Orthogonal Factor Regression (Uematsu et al. (2019)), example.","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/documentation.html","id":"tlf","dir":"Articles","previous_headings":"Refining the details","what":"test_local_factors()","title":"Getting Started","text":"function tests presence local factors given sparse basis loading space. takes input X r, additional optional argument, loadings, allows user specify loading matrix tested. argument set NULL default, estimates \\(\\hat{\\Lambda}^*\\) (maximizing l1-rotation criterion) tests local factors. construct diagnostic given loading matrix estimate, \\(\\hat{\\Lambda}\\), find column largest number entries smaller threshold \\(h_n\\): \\[ \\mathcal{L(\\hat{\\Lambda})} = \\max_k\\left(\\sum_{=1}^n 1\\{\\hat{|\\lambda}_{ik}| < h_n \\}\\right) \\] can check whether number “small” loadings larger \\(\\gamma n\\) \\[ \\texttt{has_local_factors} = 1\\{\\mathcal{L}(\\hat{\\Lambda})  \\geq \\gamma n \\}. \\] Returning lf results, can take look value has_local_factors. value result test_local_factors(). verify, can call test_local_factors() two different estimates: principal components estimate, initial_loadings, l1rotation estimate, rotated_loadings. Thus, local factors detected using principal components estimate, rotated estimate reveals two local factors. can also visualize number small loadings using small_loadings_plot element `lf’ results:","code":"lf$has_local_factors #> [1] TRUE # Check for local factors in PC estimate... test_pc_estimate <- test_local_factors(X = example_data, r = 2, loadings = lf$initial_loadings)  # And rotated estimate test_rot_estimate <- test_local_factors(X = example_data, r = 2, loadings = lf$rotated_loadings)  test_pc_estimate$has_local_factors #> [1] FALSE test_rot_estimate$has_local_factors #> [1] TRUE round_hn <- round(test_rot_estimate$h_n, digits = 3)  lf$small_loadings_plot +    ggplot2::labs(     title = 'Number of \"small\" loadings per factor',      caption = paste('\"Small\" is defined as loadings less than', round_hn)   )"},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"factor-models-primer","dir":"Articles","previous_headings":"","what":"Factor Models Primer","title":"Background and Intuition","text":"Factor models seek distill often high dimensional data set underlying latent factors capture much original variation data. say data, \\(X\\), follows factor structure : \\[ \\begin{align} \\underset{(T \\times n)}{X} = \\underset{(T \\times r)}{F} \\underset{(r \\times n)}{\\Lambda^{*'}}  + \\underset{(T \\times n)}{e} \\end{align} \\] \\(T\\) rows (observations), \\(n\\) columns (variables), \\(r\\) factors. can refer \\(\\lambda_{ik}^*\\) entry \\(\\Lambda^{*}\\) \\(\\)th row \\(k\\)th column \\(\\lambda_{ik}^*\\) shows factor \\(k\\) related , “loads onto,” variable \\(\\). Note \\(k\\)th column \\(\\Lambda^*\\) referred \\(\\lambda_k^*\\). assume number underlying factors can learned data (e.g. following procedure Bai Ng (2002) Ahn Horenstein (2013)).1 Next, ’re interested estimating loading matrix \\(\\Lambda^*\\), shows factors related data matrix \\(X\\).","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"problem-rotational-indeterminacy","dir":"Articles","previous_headings":"","what":"Problem: Rotational Indeterminacy","title":"Background and Intuition","text":"However, unique estimate \\(F\\) estimate \\(\\Lambda^*\\) satisfies equation . illustrate, let \\(H\\) nonsingular \\(r \\times r\\) matrix. can define alternative loading matrix \\(\\Lambda^0 = \\Lambda^* (H')^{-1}\\) alternative factors \\(F^0 = FH\\), follows \\[ \\begin{align} X & = F^0 \\Lambda^{0'} \\\\ & = FH (H^{-1'})' \\Lambda^{*'}\\\\ & = FH H^{-1} \\Lambda^{*'} \\\\ & = F \\Lambda^{*'} \\end{align} \\] Hence \\((F^0,\\Lambda^{0'})\\) \\((F,\\Lambda^*)\\) observationally equivalent. referred rotational indeterminacy makes interpretation estimate loading matrix delicate. arbitrary rotation \\(H\\) result alternate interpretation factors variables related. interested true relationship, \\(\\Lambda^*\\). can recover true interpretation?","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"solution-use-sparsity","dir":"Articles","previous_headings":"","what":"Solution: Use Sparsity","title":"Background and Intuition","text":"key idea Freyaldenhoven (2025) assuming sparsity pattern true loadings matrix \\(\\Lambda^*\\) solves issue rotational indeterminacy since sparsity pattern invariant rotations. Intuitively, rotation (linear combination) sparse loading vector less sparse. see , note PCA gives us estimates asymptotically linear combination true loadings vectors. , can obtain principal component vectors columns \\(\\Lambda^0\\) \\[ \\begin{align} \\Lambda^0 = \\Lambda^*(H^{-1})' + \\epsilon \\end{align} \\] \\(H\\) nonsingular \\(r \\times r\\) matrix \\(\\epsilon\\) ``small’’. Thus, \\(\\Lambda^0\\) (close ) linear combination \\(\\Lambda^*\\). However, even \\(\\Lambda^*\\) sparse, linear combinations sparse loadings \\(\\Lambda^*\\), \\(\\Lambda^0\\), generally sparse. Conversely, \\(\\Lambda^*\\) also (close ) linear combination \\(\\Lambda^0\\). Thus, must linear combination \\(\\Lambda^0\\) sparse. sparse linear combination \\(\\Lambda^0\\) estimator \\(\\Lambda^*\\).","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"recovering-sparsity","dir":"Articles","previous_headings":"","what":"Recovering Sparsity","title":"Background and Intuition","text":"Now, find sparse linear combination loading vectors? simple approach : Take principal components estimator starting point obtain \\(\\Lambda^0\\) Find loadings \\(\\Lambda^*\\) equal rotation \\(\\Lambda^0\\) minimizes number non-zero elements (\\(l_0\\) norm) loading vectors Unfortunately, \\(l_0\\) norm infeasible optimize practice. see , let’s examine figure . distance origin red point depicts \\(l_0\\) norm points along unit circle. blue points depict \\(l_1\\) norm gray points depict \\(l_2\\) norm. \\(l_2\\) case, distances remain constant traverse circle.  Geometric Intuition Various Norms \\(l_0\\) norm directly computes number nonzero elements, shown red points. (1, 0), (0, 1), (-1, 0) (0, -1), distance 1 away origin. remaining red points distance 2 away origin corresponding 2 nonzero elements points along unit circle. Since blue red dots coincide four points, \\(l_1\\) norm minimized points \\(l_0\\) norm. \\(l_1\\) norm smooth descent minima compared discontinuities \\(l_0\\) norm around minima. makes \\(l_1\\) easier minimize. Thus, maximize sparsity minimize \\(l_1\\) norm instead \\(l_0\\) norm. Formally, using \\(l_1\\) norm, objective function becomes \\[ \\begin{align} \\min_R ||\\Lambda^0R||_1 \\end{align} \\] \\(R\\) nonsingular \\(||r_k||_2 = 1\\) \\(r_k\\) row \\(R\\). keeps length loading vector fixed, ensuring look rotations initial loading vector. Since length remains constant, can transform constrained optimization problem unconstrained one converting polar coordinates. example, case two factors, constrained version want find weights \\(w_1, w_2\\) minimize \\[ || w_1 \\lambda_1^0 + w_2 \\lambda_2^0 ||_1 \\quad s.t. \\quad w_1^2 + w_2^2 = 1. \\] spherical coordinates, amounts finding angle \\(\\theta\\) minimizes \\[ ||\\lambda_1^0 \\cos \\theta + \\lambda_2^0 \\sin \\theta ||_1. \\]","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"objective-function","dir":"Articles","previous_headings":"","what":"Objective Function","title":"Background and Intuition","text":"Formally, using \\(l_1\\) norm, objective function becomes \\[ \\begin{align} \\min_R ||\\Lambda^0R||_1 \\end{align} \\] \\(R\\) nonsingular \\(||r_k||_2 = 1\\) \\(r_k\\) row \\(R\\). keeps length loading vector fixed, ensuring look rotations initial loading vector. Since length remains constant, can transform constrained optimization problem unconstrained one converting polar coordinates. example, case two factors, constrained version want find weights \\(w_1, w_2\\) minimize \\[ || w_1 \\lambda_1^0 + w_2 \\lambda_2^0 ||_1 \\quad s.t. \\quad w_1^2 + w_2^2 = 1. \\] spherical coordinates, amounts finding angle \\(\\theta\\) minimizes \\[ ||\\lambda_1^0 \\cos \\theta + \\lambda_2^0 \\sin \\theta ||_1. \\]","code":""},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"a-simple-example","dir":"Articles","previous_headings":"","what":"A simple example","title":"Background and Intuition","text":"Let’s consider example can visualize fully: ’ll use following simulated data three columns (\\(n = 3\\)) suppose know two factors, \\(r = 2\\). first 6 224 total rows printed. Let true loadings matrix, \\(\\Lambda^*\\) 2 columns 3 rows. can see sparsity pattern matrix first factor affecting first column second factor affecting second third columns \\(X\\). Now, let’s look PCA estimator \\(X\\) first two principal components. zeroes longer present, principal component estimate still provides great starting point generally linear combinations true loading vectors \\(n \\\\infty\\) (e.g., Bai (2003)). Let’s try get clearer picture far visualizing components. interactive visualization data points, \\(X\\) plane spanned principal component vectors (blue plane) principal component vectors \\(\\Lambda^0\\) (blue) true loading vectors \\(\\Lambda^*\\) (orange) can see, blue principal component vectors span blue plane. definition, two vectors provide directions maximal variance data. can also imagine data cloud projected onto plane give us sense data compressed 3 2 dimensions. Notice blue vectors nowhere near true loading vectors shown orange. However, simply rotating blue vectors give us solutions closer true vectors. Using sliders control angle rotation vector separately, try rotating blue vectors along plane find rotation lines close possible orange vectors. Since \\(n = 3\\) small, can see noise PC estimate, resulting loading vectors located slightly plane. Still, can get better estimate true vectors rotating. try different angles rotation can see impact objective function ’re optimizing . rotation best aligns true loadings vectors also occur local minima objective function. Note several minima exist due sign indeterminacy, .e., multiplying sparse loading vector -1 change sparsity interpretation. visualizations show relationship angles rotation, objective function optimizing sparsity, position vectors space relative true loadings. crux intuition behind research accompanying package.","code":"V1         V2         V3 1  0.4814018  0.7468954 -1.4401043 2 -0.8309668 -0.6558851  1.5983829 3  0.2360548  0.8199547  1.8496925 4  0.3685305  0.9678467 -1.1387934 5 -0.5266293  0.3336697 -0.0650335 6 -0.2464255 -0.5563491  0.8534258 loadings_1 loadings_2 1   1.024946  0.0000000 2   0.000000  1.3517553 3   0.000000  0.2765392 loadings_1 loadings_2 1 -1.2668929 -0.2153919 2 -0.8709413 -0.9799329 3  0.7977743 -1.4118561 math = require('https://cdnjs.cloudflare.com/ajax/libs/mathjs/1.5.2/math.min.js') d3 = require(\"d3@3\")  THREE = {   const THREE = window.THREE = await require(\"three@0.130.0/build/three.min.js\");   await require(\"three@0.130.0/examples/js/controls/OrbitControls.js\").catch(() => {});   return THREE; } renderer.domElement viewof theta1_value = Inputs.range(   [-3.13, 3.13],    {value: 0, step: .01, label: \"Vector 1 angle (θ):\"} )  viewof theta2_value = Inputs.range(   [-3.13, 3.13],    {value: 1.57, step: .01, label: \"Vector 2 angle (θ):\"} ) highlighted_points = obj_data.filter(function(angle) {   return (theta1_value - 0.005 < angle.theta && theta1_value + 0.005 > angle.theta) ||          (theta2_value - 0.005 < angle.theta && theta2_value + 0.005 > angle.theta) })  obj_data = FileAttachment(\"obj_function_data.csv\").csv({typed: true});  Plot.plot({   height: 150,   width: 700,   grid: true,   marks: [     Plot.dot(obj_data, {       x: \"theta\",        y: \"y\",       r: 1     }),     Plot.dot(highlighted_points, {       x: \"theta\",        y: \"y\",        fill: \"#0000FF\",        r: 5     })   ],   x: {   label: \"θ\" },   y: {     label: \"\"   },   title: \"Objective function: ||λ₁⁰ cos θ + λ₂⁰ sin θ ||₁\",   style: {     background: \"transparent\",     fontSize: 12   } }) height = 450; camera = {   const fov = 45;   const aspect = width / height;   const near = 1;   const far = 1000;   const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);   camera.position.set(-2*2, 2*2, -2*2)   camera.lookAt(new THREE.Vector3(0, 0, 0));   return camera; }  gridHelper = {const size = 10; const divisions = 10;  const gridHelper = new THREE.GridHelper( size, divisions ); return gridHelper; }  renderer = {   const renderer = new THREE.WebGLRenderer({antialias: true});   renderer.setSize(width, height);   renderer.setPixelRatio(devicePixelRatio);   const controls = new THREE.OrbitControls(camera, renderer.domElement);   controls.addEventListener(\"change\", () => renderer.render(scene, camera));   invalidation.then(() => (controls.dispose(), renderer.dispose()));   return renderer; } pca_vectors = await FileAttachment('lambda0.csv').csv({typed: true}) true_vectors = await FileAttachment('truth_normal.csv').csv({typed: true})   display_arrow = {const dir = new THREE.Vector3( pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          display_arrow2 = {const dir = new THREE.Vector3( pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                   true_vector1 = {const dir = new THREE.Vector3( true_vectors[0].V1, true_vectors[1].V1, true_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          true_vector2 = {const dir = new THREE.Vector3( true_vectors[0].V2, true_vectors[1].V2, true_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                     math_plane = {   const v1 = new THREE.Vector3(pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);   const v2 = new THREE.Vector3(pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);   const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();      // Create a plane with normal   const plane = new THREE.Plane(normal);      // Create a PlaneGeometry (size 4x4 units, with sufficient segments)   const planeGeometry = new THREE.PlaneGeometry(4, 4, 1, 1);      // Create a material with transparency   const planeMaterial = new THREE.MeshBasicMaterial({     color: 0x6495ED,      transparent: true,     opacity: 0.5,     // 50% opacity, adjust as needed     side: THREE.DoubleSide // Visible from both sides   });      // Create the mesh   const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);      // Position and orient the plane correctly   // First, find a point on the plane (using the plane equation)   const pointOnPlane = new THREE.Vector3();   // You can set this to origin or any other point you prefer   plane.projectPoint(new THREE.Vector3(0, 0, 0), pointOnPlane);      // Set the position   planeMesh.position.copy(pointOnPlane);      // Orient the plane to match your normal vector   planeMesh.lookAt(pointOnPlane.clone().add(normal));      // Store both the plane object (for calculations) and the mesh (for display)   return {     plane: plane,     mesh: planeMesh   }; }   points = {   const data = await FileAttachment('data.csv').csv({typed: true});   const geometry = new THREE.BufferGeometry();   const positions = new Float32Array(data.flatMap(d => [d.V1, d.V2, d.V3]));   geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));    const material = new THREE.PointsMaterial({color: 0x000000, size: 0.1});   const points = new THREE.Points(geometry, material);   return points; } scene = {   const scene = new THREE.Scene();   scene.background = new THREE.Color(0xffffff);   scene.add(gridHelper);   scene.add(display_arrow);   scene.add(display_arrow2);   scene.add(true_vector1);   scene.add(true_vector2);   scene.add(math_plane.mesh);   scene.add(points);   return scene; }  update1 = {   // For the first vector v1   const x1 = Math.cos(theta1_value);   const y1 = Math.sin(theta1_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x1 * pca_vectors[0].V1 + y1 * pca_vectors[0].V2,     x1 * pca_vectors[1].V1 + y1 * pca_vectors[1].V2,     x1 * pca_vectors[2].V1 + y1 * pca_vectors[2].V2   ).normalize();      display_arrow.setDirection(new_direction);   renderer.render(scene, camera);   return; }  update2 = {   // For the first vector v1   const x2 = Math.cos(theta2_value);   const y2 = Math.sin(theta2_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x2 * pca_vectors[0].V1 + y2 * pca_vectors[0].V2,     x2 * pca_vectors[1].V1 + y2 * pca_vectors[1].V2,     x2 * pca_vectors[2].V1 + y2 * pca_vectors[2].V2   ).normalize();      display_arrow2.setDirection(new_direction);   renderer.render(scene, camera);   return; }"},{"path":"https://kobleary.github.io/l1rotation/articles/intuition.html","id":"interactive-visualization","dir":"Articles","previous_headings":"","what":"Interactive Visualization","title":"Background and Intuition","text":"can see, blue principal component vectors span blue plane. definition, two vectors provide directions maximal variance data. can also imagine data cloud projected onto plane give us sense data compressed 3 2 dimensions. Notice blue vectors nowhere near true loading vectors shown orange. However, simply rotating blue vectors give us solutions closer true vectors. Using sliders control angle rotation vector separately, try rotating blue vectors along plane find rotation lines close possible orange vectors. Since \\(n = 3\\) small, can see noise PC estimate, resulting loading vectors located slightly plane. Still, can get better estimate true vectors rotating. try different angles rotation can see impact objective function ’re optimizing . rotation best aligns true loadings vectors also occur local minima objective function. Note several minima exist due sign indeterminacy, .e., multiplying sparse loading vector -1 change sparsity interpretation. visualizations show relationship angles rotation, objective function optimizing sparsity, position vectors space relative true loadings. crux intuition behind research accompanying package.","code":"math = require('https://cdnjs.cloudflare.com/ajax/libs/mathjs/1.5.2/math.min.js') d3 = require(\"d3@3\")  THREE = {   const THREE = window.THREE = await require(\"three@0.130.0/build/three.min.js\");   await require(\"three@0.130.0/examples/js/controls/OrbitControls.js\").catch(() => {});   return THREE; } renderer.domElement viewof theta1_value = Inputs.range(   [-3.13, 3.13],    {value: 0, step: .01, label: \"Vector 1 angle (θ):\"} )  viewof theta2_value = Inputs.range(   [-3.13, 3.13],    {value: 1.57, step: .01, label: \"Vector 2 angle (θ):\"} ) highlighted_points = obj_data.filter(function(angle) {   return (theta1_value - 0.005 < angle.theta && theta1_value + 0.005 > angle.theta) ||          (theta2_value - 0.005 < angle.theta && theta2_value + 0.005 > angle.theta) })  obj_data = FileAttachment(\"obj_function_data.csv\").csv({typed: true});  Plot.plot({   height: 150,   width: 700,   grid: true,   marks: [     Plot.dot(obj_data, {       x: \"theta\",        y: \"y\",       r: 1     }),     Plot.dot(highlighted_points, {       x: \"theta\",        y: \"y\",        fill: \"#0000FF\",        r: 5     })   ],   x: {   label: \"θ\" },   y: {     label: \"\"   },   title: \"Objective function: ||λ₁⁰ cos θ + λ₂⁰ sin θ ||₁\",   style: {     background: \"transparent\",     fontSize: 12   } }) height = 450; camera = {   const fov = 45;   const aspect = width / height;   const near = 1;   const far = 1000;   const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);   camera.position.set(-2*2, 2*2, -2*2)   camera.lookAt(new THREE.Vector3(0, 0, 0));   return camera; }  gridHelper = {const size = 10; const divisions = 10;  const gridHelper = new THREE.GridHelper( size, divisions ); return gridHelper; }  renderer = {   const renderer = new THREE.WebGLRenderer({antialias: true});   renderer.setSize(width, height);   renderer.setPixelRatio(devicePixelRatio);   const controls = new THREE.OrbitControls(camera, renderer.domElement);   controls.addEventListener(\"change\", () => renderer.render(scene, camera));   invalidation.then(() => (controls.dispose(), renderer.dispose()));   return renderer; } pca_vectors = await FileAttachment('lambda0.csv').csv({typed: true}) true_vectors = await FileAttachment('truth_normal.csv').csv({typed: true})   display_arrow = {const dir = new THREE.Vector3( pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          display_arrow2 = {const dir = new THREE.Vector3( pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0x0000FF;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                   true_vector1 = {const dir = new THREE.Vector3( true_vectors[0].V1, true_vectors[1].V1, true_vectors[2].V1);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }          true_vector2 = {const dir = new THREE.Vector3( true_vectors[0].V2, true_vectors[1].V2, true_vectors[2].V2);  //normalize the direction vector (convert to vector of length 1) dir.normalize();  const origin = new THREE.Vector3( 0, 0, 0 ); const length = 1; const hex = 0xFF664F;  const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ); return arrowHelper;         }                     math_plane = {   const v1 = new THREE.Vector3(pca_vectors[0].V1, pca_vectors[1].V1, pca_vectors[2].V1);   const v2 = new THREE.Vector3(pca_vectors[0].V2, pca_vectors[1].V2, pca_vectors[2].V2);   const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();      // Create a plane with normal   const plane = new THREE.Plane(normal);      // Create a PlaneGeometry (size 4x4 units, with sufficient segments)   const planeGeometry = new THREE.PlaneGeometry(4, 4, 1, 1);      // Create a material with transparency   const planeMaterial = new THREE.MeshBasicMaterial({     color: 0x6495ED,      transparent: true,     opacity: 0.5,     // 50% opacity, adjust as needed     side: THREE.DoubleSide // Visible from both sides   });      // Create the mesh   const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);      // Position and orient the plane correctly   // First, find a point on the plane (using the plane equation)   const pointOnPlane = new THREE.Vector3();   // You can set this to origin or any other point you prefer   plane.projectPoint(new THREE.Vector3(0, 0, 0), pointOnPlane);      // Set the position   planeMesh.position.copy(pointOnPlane);      // Orient the plane to match your normal vector   planeMesh.lookAt(pointOnPlane.clone().add(normal));      // Store both the plane object (for calculations) and the mesh (for display)   return {     plane: plane,     mesh: planeMesh   }; }   points = {   const data = await FileAttachment('data.csv').csv({typed: true});   const geometry = new THREE.BufferGeometry();   const positions = new Float32Array(data.flatMap(d => [d.V1, d.V2, d.V3]));   geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));    const material = new THREE.PointsMaterial({color: 0x000000, size: 0.1});   const points = new THREE.Points(geometry, material);   return points; } scene = {   const scene = new THREE.Scene();   scene.background = new THREE.Color(0xffffff);   scene.add(gridHelper);   scene.add(display_arrow);   scene.add(display_arrow2);   scene.add(true_vector1);   scene.add(true_vector2);   scene.add(math_plane.mesh);   scene.add(points);   return scene; }  update1 = {   // For the first vector v1   const x1 = Math.cos(theta1_value);   const y1 = Math.sin(theta1_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x1 * pca_vectors[0].V1 + y1 * pca_vectors[0].V2,     x1 * pca_vectors[1].V1 + y1 * pca_vectors[1].V2,     x1 * pca_vectors[2].V1 + y1 * pca_vectors[2].V2   ).normalize();      display_arrow.setDirection(new_direction);   renderer.render(scene, camera);   return; }  update2 = {   // For the first vector v1   const x2 = Math.cos(theta2_value);   const y2 = Math.sin(theta2_value);      // Linear combination: v1 = x1*V1 + y1*V2   const new_direction = new THREE.Vector3(     x2 * pca_vectors[0].V1 + y2 * pca_vectors[0].V2,     x2 * pca_vectors[1].V1 + y2 * pca_vectors[1].V2,     x2 * pca_vectors[2].V1 + y2 * pca_vectors[2].V2   ).normalize();      display_arrow2.setDirection(new_direction);   renderer.render(scene, camera);   return; }"},{"path":"https://kobleary.github.io/l1rotation/articles/macro_application.html","id":"macroeconomic-indicators","dir":"Articles","previous_headings":"","what":"Macroeconomic Indicators","title":"Application","text":"Let’s now apply l1rotation package large panel US macroeconomic indicators, following one examples provided Freyaldenhoven (2025). dataset FRED_QD data collected maintained Michael W. McCracken available . specific example uses data 1967Q1-2019Q1 follows transformations recommended McCracken Ng (2016) remove outliers. aggregated data series dropped well. final cleaned sample used paper consists disaggregated stationary time series can found . information, see paper. Let’s read . Using information criterion Bai Ng (2002), determine data 8 factors. get idea information data conveys, can categorize outcome variable one 14 groups :  Grouping variables panel US macroeconomic indicators, Freyaldenhoven (2025) Now, let’s try estimate 8 local factors.  Based plot , sparsity pattern estimated loading matrix makes result interpretable. first factor corresponds group 6 corresponds price variables - suggesting interpretation factor price index. second factor mainly affects interest rates, employment indicators, industrial production third factor affects household balance sheets stock markets. picture somewhat less clear factors 4-8. Finally, plotting number small loadings estimated loading vectors, find evidence existence local factors dataset.","code":"library(l1rotation)  fred <- read.csv(file.path(me, \"fred.csv\"), header = FALSE) dim(fred) #> [1] 206 166 head(fred[,1:7]) #>         V1      V2       V3       V4       V5        V6      V7 #> 1 -0.93618 1.35640 -0.95510 -1.06600 -0.72831  1.163400 1.21780 #> 2 -0.48721 0.17344 -0.16558  0.68259  0.45872  1.285800 1.03640 #> 3  1.96610 1.82430  2.02730  0.91550  0.95781 -0.041807 0.85503 #> 4  0.30228 1.77050  0.97072 -1.48240 -1.31120  0.487860 1.94340 #> 5  1.27660 1.14510  1.49440  0.41494  0.11338  0.385080 0.67363 #> 6 -0.84318 0.75985 -0.78434  0.79395  0.84148  0.226120 0.31084 set.seed(916)  fred_lf <- local_factors(fred, 8) #> Finding rotations ■■■■                               9% | ETA: 44s #> Finding rotations ■■■■■■■                           21% | ETA: 40s #> Finding rotations ■■■■■■■■■                         25% | ETA: 39s #> Finding rotations ■■■■■■■■■■                        30% | ETA: 39s #> Finding rotations ■■■■■■■■■■■                       34% | ETA: 38s #> Finding rotations ■■■■■■■■■■■■■                     39% | ETA: 35s #> Finding rotations ■■■■■■■■■■■■■■                    43% | ETA: 33s #> Finding rotations ■■■■■■■■■■■■■■■■                  49% | ETA: 30s #> Finding rotations ■■■■■■■■■■■■■■■■■                 54% | ETA: 26s #> Finding rotations ■■■■■■■■■■■■■■■■■■■               60% | ETA: 22s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■             66% | ETA: 19s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■           73% | ETA: 15s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■         79% | ETA: 12s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■        84% | ETA:  9s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■      89% | ETA:  6s #> Finding rotations ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    96% | ETA:  2s  variable_groups <- c(15, 27, 61, 69, 75, 109,                      115, 128, 137, 143, 147, 148, 154)  fred_lf$rotated_plot +   ggplot2::geom_hline(yintercept = variable_groups, lty = \"longdash\") fred_lf$small_loadings_plot"},{"path":"https://kobleary.github.io/l1rotation/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Simon Freyaldenhoven. Author, copyright holder. Ryan Kobler. Author, maintainer.","code":""},{"path":"https://kobleary.github.io/l1rotation/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Freyaldenhoven S, Kobler R (2025). “l1rotation package.” https://github.com/SimonFreyaldenhoven/l1rotation.","code":"@Misc{,   title = {l1rotation package},   author = {Simon Freyaldenhoven and Ryan Kobler},   url = {https://github.com/SimonFreyaldenhoven/l1rotation},   year = {2025}, }"},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"l1rotation package implements l1-rotation criterion Freyaldenhoven (2025) simplify loading matrix factor models.","code":""},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"","code":"# Install from CRAN install.packages(\"l1rotation\")  # Install latest version from GitHub install.packages(\"devtools\") devtools::install_github(\"SimonFreyaldenhoven/l1rotation\")"},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"Find minimal example . information see package website, documentation vignette.","code":"library(l1rotation) set.seed(916)   # Minimal example with 2 factors, where X is a 224 by 207 matrix lf <- local_factors(X = example_data, r = 2)  # Rerun with parallel processing lf_lambdas <- local_factors(X = example_data, r = 2, parallel = TRUE, n_cores = 10)  # Visualize Principal Component estimate of the loadings lf$pc_plot # Visualize l1-rotation loadings lf$rotated_plot"},{"path":"https://kobleary.github.io/l1rotation/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Identify Loading Vectors under Sparsity in Factor Models","text":"Simon Freyaldenhoven. “Identification Sparsity Factor Models: l1-rotation criterion.” Philadelphia Fed Working Paper 20-25, February 2025. Simon Freyaldenhoven, Ryan Kobler. “l1rotation package.” Code data repository https://github.com/SimonFreyaldenhoven/l1rotation, March 2025.","code":""},{"path":"https://kobleary.github.io/l1rotation/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 l1rotation authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data with two factors from the replication files of Freyaldenhoven et. al (2025). — example_data","title":"Example data with two factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"Example data two factors replication files Freyaldenhoven et. al (2025).","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data with two factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"","code":"example_data"},{"path":[]},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":"example-data","dir":"Reference","previous_headings":"","what":"example_data","title":"Example data with two factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"matrix 224 rows 207 columns.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/example_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example data with two factors from the replication files of Freyaldenhoven et. al (2025). — example_data","text":"Dataset available .mat file can generated local_factors.zip https://simonfreyaldenhoven.github.io/software/","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"Find sparse rotation orthonormal basis loading space t n matrix X. Additional flexibility initial_loadings argument allows user specify orthonormal basis rather defaulting PCA.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"","code":"find_local_factors(X, r, initial_loadings, parallel = FALSE, n_cores = NULL)"},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"X (usually standardized) t n matrix observations. r integer denoting number factors X. initial_loadings Matrix represents orthonormal basis loading space. supplied, PCA used default function also local_factors. parallel logical denoting whether algorithm run parallel. n_cores integer denoting many cores used, parallel == TRUE.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"Returns list following components: initial_loadings Principal Component estimate loading matrix (supplied). rotated_loadings Matrix rotation loading matrix produces smallest l1-norm. rotation_diagnostics list containing 3 components: R Rotation matrix used rotate initial_loadings produces smallest l1-norm. l1_norm Vector length r containing value l1 norm solution generates. sol_frequency Vector length r containing frequency initial grid solution.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/find_local_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the rotation of the loading matrix with the smallest l1-norm, as in local_factors(), with additional flexibility. — find_local_factors","text":"","code":"# Minimal example with 2 factors, where X is a 224 by 207 matrix r <- 2 M <- nrow(example_data) n <- ncol(example_data)  # Compute PCA estimates basis <- svd(example_data / sqrt(M), nu = M, nv = n) initial_loadings <- sqrt(n) * basis$v[, 1:r]  # Find minimum rotation using orthonormal basis initial_loadings rotation_result <- find_local_factors(X = example_data, r = r, initial_loadings = initial_loadings)"},{"path":"https://kobleary.github.io/l1rotation/reference/l1rotation-package.html","id":null,"dir":"Reference","previous_headings":"","what":"l1rotation: Identify Loading Vectors under Sparsity in Factor Models — l1rotation-package","title":"l1rotation: Identify Loading Vectors under Sparsity in Factor Models — l1rotation-package","text":"Simplify loading matrix factor models using l1 criterion proposed Freyaldenhoven (2025) https://doi.org/10.21799/frbp.wp.2020.25. Given data matrix, find rotation loading matrix smallest l1-norm /test presence local factors main function local_factors().","code":""},{"path":[]},{"path":"https://kobleary.github.io/l1rotation/reference/l1rotation-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"l1rotation: Identify Loading Vectors under Sparsity in Factor Models — l1rotation-package","text":"Maintainer: Ryan Kobler kobleary@gmail.com Authors: Simon Freyaldenhoven simon.freyaldenhoven@phil.frb.org [copyright holder]","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"local_factors tests whether local factors present returns Principal Component estimate loadings rotation loadings smallest l1-norm. also produces graphical illustrations results.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"","code":"local_factors(X, r, parallel = FALSE, n_cores = NULL)"},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"X (usually standardized) t n matrix observations. r integer denoting number factors X. parallel logical denoting whether algorithm run parallel. n_cores integer denoting many cores used, parallel == TRUE.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"Returns list following components: has_local_factors logical equal TRUE local factors present. initial_loadings Principal component estimate loading matrix. rotated_loadings Matrix rotation loading matrix produces smallest l1-norm. rotation_diagnostics list containing 3 components: R Rotation matrix used rotate initial_loadings produces smallest l1-norm. l1_norm Vector length r containing value l1 norm solution generates. sol_frequency Vector length r containing frequency initial grid solution. pc_plot Tile plot Principal Component estimate loading matrix. rotated_plot Tile plot l1-rotation loading matrix estimate. small_loadings_plot Plot number small loadings column l1-rotation loading matrix estimate.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/local_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check whether local factors are present and find the rotation of the loading matrix with the smallest l1-norm. — local_factors","text":"","code":"# Minimal example with 2 factors, where X is a 224 by 207 matrix lf <- local_factors(X = example_data, r = 2)  # Visualize Principal Component estimate of the loadings lf$pc_plot   # Visualize l1-rotation loadings lf$pc_rotated_plot #> NULL"},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"Test presence local factors, local_factors(), additional flexibility.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"","code":"test_local_factors(X, r, loadings = NULL)"},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"X (usually standardized) t n matrix observations. r integer denoting number factors X. loadings (optional) Matrix represents sparse basis loading space.","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"Returns list following components: has_local_factors Logical equal TRUE local factors present. n_small Integer denoting number small loadings sparse rotation. gamma_n Integer denoting critical value compare n_small . h_n Number denoting cutoff used determine loadings small. loadings Matrix rotation loadings produces smallest l1-norm (supplied).","code":""},{"path":"https://kobleary.github.io/l1rotation/reference/test_local_factors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for the presence of local factors, as in local_factors(), with additional flexibility. — test_local_factors","text":"","code":"# Minimal example with 2 factors, where X is a 224 by 207 matrix r <- 2 M <- nrow(example_data) n <- ncol(example_data)  # Find minimum rotation rotation_result <- find_local_factors(X = example_data, r)  # Test if sparse basis has local factors test_result <- test_local_factors(    X = example_data,    r = r,    loadings = rotation_result$rotated_loadings )  test_result$has_local_factors #> [1] TRUE"},{"path":[]},{"path":"https://kobleary.github.io/l1rotation/news/index.html","id":"l1rotation-v002","dir":"Changelog","previous_headings":"","what":"l1rotation v0.0.2","title":"l1rotation v0.0.2","text":"Initial CRAN submission. Adds core functionality user functions local_factors(), find_local_factors(), test_local_factors() Updates arguments results loadings rather Lambda throughout","code":""}]
